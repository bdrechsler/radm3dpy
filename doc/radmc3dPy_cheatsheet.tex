\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[left=1.5cm, right=1.5cm, top=1.5cm, bottom=1.5cm]{geometry}
\usepackage{color}
\usepackage{colortbl}
\usepackage{tikz}
\usetikzlibrary{shapes, shadows, arrows}


\definecolor{darkgreen}{RGB}{0,150,0}
\definecolor{lblue}{RGB}{200,200,250}
\definecolor{lgreen}{RGB}{200,250,200}
\definecolor{lred}{RGB}{250,200,200}
\definecolor{yellow}{RGB}{230,230,150}

\renewcommand{\rmdefault}{phv}
\newcommand{\pymod}{{\tt  radmc3dPy }}


\begin{document}

% Some Tikz definitions for the flowchart
\tikzstyle{decision} = [diamond, draw, fill=blue!50]
\tikzstyle{line} = [draw, -stealth, thick]
\tikzstyle{output}=[draw, ellipse, fill=green!50,minimum height=8mm, text width=7em, text centered]
\tikzstyle{calc}=[draw, ellipse, fill=red!40,minimum height=8mm, text width=10em, text centered]
\tikzstyle{input} = [draw, rectangle, fill=blue!30, text width=12em, text centered, minimum height=15mm, node distance=5em]
\tikzstyle{opinput} = [draw, rectangle, fill=yellow!50, text width=12em, text centered, minimum height=15mm, node distance=5em]



\begin{center}
{\huge\bf radmc3dPy v0.25}\\
\vspace{0.5cm}
{\large Attila Juh\'asz}
\end{center}

\pymod consists of three parts: 1) few core modules (analyze, image, natconst, setup) for creating input files and post-processing
the output of RADMC-3D, 2) an ensemble of models to provide description for the physical variables in the model space and 
3) an input parameter file. 

\section{Core modules}
\label{sec:core}

\subsection{module: setup}
\label{subsec:setup}

This module is responsible for model setup (those who are familiar with the IDL package of the predecessor code radmc this
module is similar to 'problem\_setup.pro'). The setup module contains two separate functions to set up a dust and a gas model
possibly independently from each other problemSetupDust() and problemSetupGas(). It depends on the actual model whether 
or not they are completely independent from each other. These functions have one mandatory  argument, the name of the model. Any
additional keyword argument can be used to change/override the model parameters (as set in the input parameter file). The basic 
steps of a model setup are the 
following: 1) Read the input parameter file. 2) Check if any of the parameters were given as
keyword argument for the setup function and if so set its value to the one given in the keyword argument. If such parameter
override happens re-write the input parameter file with the actual parameter setup. 3) Create all the necessary input files.
The setup module has also two convenience function to query the current set of available models and get a one line
description of that. The most important functions in the setup module are the following:


\begin{itemize}
\item[] {\bf getModelDesc()} - Returns the brief description of the model
\item[] {\bf getModelNames()} - Returns the list of available models
\item[] {\bf problemSetupDust()} - Creats a dust continuum model setup
\item[] {\bf problemSetupGas()} - Creates a gas model setup
\end{itemize}

\subsection{module: analyze}
\label{subsec:analyze}

This module is responsible for I/O and some basic analytical functionality. It contains five classes 
(radmc3dData, radmc3dDustOpac, radmc3dGrid, radmc3dPar, radmc3dStars) and several functions. 
The radmc3dData class is responsible for the reading and writing of the variables (density, temperature, 
etc.), whatever radmc3dData can read it can also write it both in formatted ASCII or in C-style binary format. 
It also contains functions to calculate continuum optical depths and surface density. The radmc3dDustopac class
contains methods to  read/write the master opacity file (dustopac.inp), read dust opacities and also to calculate
them. For the dust opacity calculation it uses the code 'makedust' distributed with RADMC-3D (opac/dust\_continuum/jena). 
The code in opac/dust\_continuum/jena should be compiled and the directory should be added to the PATH environment
variable such that it can be called/executed without the absolute path. The radmc3dGrid class has methods to create, read and 
write spatial and wavelength grid and to calculate the grid cell volumes. The radmc3dPar is the model parameter class. 
It can read and write the  model parameter file (problem\_params.inp). It has dictionaries to store the variables with the
variable names as keys. 

Important functions in the analyse module:
\begin{itemize}
\item[]{\bf readData()} - Reads variables (e.g. dust density, gas velocity, etc)
\item[]{\bf readGrid()} - Reads the spatial and frequency grid
\item[]{\bf readOpac()} - Reads the dust opacities
\item[]{\bf readParams()} - Reads the parameter file (problem\_params.inp)
\item[]{\bf writeDefaultParfile()} - Writes the default parameters for a model
\item[]{\bf radmc3dData.getSigmadust()} - Calculates the dust surface density in g/cm$^2$
\item[]{\bf radmc3dData.getSigmagas()} - Calculates the gas surface density in molecule/cm$^2$
\item[]{\bf radmc3dData.getTau()} - Calculates the continuum optical depth 
\item[]{\bf radmc3dData.writeVTK()} - Writes variables to a VTK format for visualisation with e.g. Paraview 
\end{itemize}

\subsection{module: image}
\label{subsec:image}

The image module provides functionality to read/write images and do some simple manipulation of them. 
The base class is the radmc3dImage class. It can read images both in formatted ASCII and in C-style binary format 
and write images in FITS format. For the latter it uses the fits module of the astropy package, formerly known as 
PyFits (radmc3dPy can use any of them). Images can be convolved with an arbitrary 2D Gaussian beam 
using the imConv method of the radmc3dImage class. The images can be displayed with the plotImage() function, 
that uses matplotlib to display the image. A coronographic mask can also be simulated with the cmask() function, 
i.e. within a certain radius around the image center the pixel values will be set to zero.  Some convenience/interface 
functions are also present (e.g. plotImage(), makeImage(), readImage(), etc.). 

\begin{itemize}
\item[]{\bf makeImage()} - Calculates an image with RADMC-3D (both dust continuum and channel maps)
\item[]{\bf plotImage()} - Plot the image / channel map
\item[]{\bf readImage()} - Reads the image 
\item[]{\bf radmc3dImage.imConv()} - Convolve the image with a Gaussian beam 
\item[]{\bf radmc3dImage.plotMomentmap()} - Plots moment map for a 3d image cube
\item[]{\bf radmc3dImage.writeFits()} - Writes the image to a FITS file with CASA compatible header
\end{itemize}

\section{Models}
\label{sec:model}

While the core modules contain functionality how to read and write the input files the model modules
should contain the rules what the physical structure of the model is, i.e. the distribution of density, velocity, 
turbulent velocity, etc. as a function of the spatial coordinates. Each model module must be named as
'model\_NAME.py' where NAME stands for the name of the model (e.g. model\_ppdisk.py). The files
themselves must be located either in the current working directory or in the radmc3dPy directory wherever
it is installed. Models are always tried to be imported from the current working directory first. 
Each model module can contain the following functions:
\begin{itemize}
\item[] getModelDesc() - contains a one sentence description of the model
\item[] getDefaultParams() - contains the default parameters for this model
\item[] getDustDensity() - calculates the dust density, and returns as a numpy array
\item[] getDustTemperature() - if present it should return the dust temperature as a bumpy array 
\item[] getGasAbundance() - returns the gas abundance 
\item[] getGasDensity() - returns the gas density
\item[] getGasTemperature() - returns the gas temperature
\item[] getVelocity() - returns the velocity 
\item[] getVTurb() - returns the microturbulent velocity
\end{itemize}
Each function that should return a variable gets the spatial grid and all model parameters as input  arguments
and they should return numpy arrays containing the variable. 

\section{Parameter file}
\label{sec:parfile}
The parameter file ('problem\_params.inp') contains all input parameters for the model in an plain text format. Its structure 
resembles very closely the input parameter file of the predecessor code, radmc. Variables are grouped into blocks according to their
meaning, e.g. radiation source parameters, grid parameters, dust opacity, etc. Each parameter in the file is given in the following
format: 

variableName = variableValue \# Comment

The reader method of the radmc3dPar class will try to interpret each line according to this general recipe. 
However, there is some freedom in this formalism. The variable value can be any expression, also broken into multiple lines. 
The value expression of a variable can also include another variable defined anywhere {\it above} that line. 

\newpage
\section*{Dust continuum model setup} 

\begin{figure}[!hp]
\begin{center}
\scalebox{0.8}{
\begin{tikzpicture}

% Input nodes
\node [input] (grid) {{\bf Spatial \& Frequency grid}\\amr\_grid.inp, \\wavelength\_micron.inp};
\node [input, below of=grid, yshift=-2.em] (radsource) {{\bf Radiation source(s)} \\ stars.inp};
\node [input, below of=radsource, yshift=-2.em] (dustopac) {{\bf Dust opacity} \\ dustkappa\_xxx.inp, dustopac.inp};
\node [input, below of=dustopac, yshift=-2.em] (dustdens) {{\bf Dust density} \\ dust\_density.inp};
\node [input, below of=dustdens, yshift=-2.em] (codepar) {{\bf Code parameters} \\ radmc3d.inp};

% MC calculation
\node [calc, right of=dustopac, xshift=13.em] (thermalmc) {{\bf Themal Monte-Carlo ($\rightarrow$ T$_{\rm dust}$)} \\ dust\_temperature.dat};

% Observables
\node [output, right of=thermalmc, xshift=13.em, yshift=5em] (contsed) {{\bf Raytracing \\ SED} \\ spectrum.out};
\node [output, right of=thermalmc, xshift=13.em, yshift=-5em] (contimag) {{\bf Raytracing \\ Image} \\ image.out};

% Lines/arrows
\path [line] (grid) -| node[xshift=3em, yshift=-10em] {} (thermalmc);
\path [line] (radsource) -| node[xshift=1em, yshift=-10em] {} (thermalmc);
\path [line] (dustopac) -- (thermalmc);
\path [line] (dustdens) -| node[xshift=3em, yshift=10em] {} (thermalmc);
\path [line] (codepar) -| node[xshift=1em, yshift=10em] {} (thermalmc);

\path [line] (thermalmc) -- (contsed);
\path [line] (thermalmc) -- (contimag);

\end{tikzpicture}}
\end{center}
\caption{Structure of a dust continuum model. Inputs are marked with blue, intermediate calculation, data products are
in red while green marks the output of the simulation.}
\end{figure}

\subsection*{radmc3dPy commands}
First let us create a directory for our model. Then go to this directory and start python. 

\begin{itemize}
\item[1] Import \pymod.

{\tt >>> import radmc3dPy}\\
\item[2] Check which models are available:

{\tt >>> radmc3dPy.setup.getModelNames()}\\
\indent {\tt ['lines\_nlte\_lvg\_1d\_1', 'ppdisk', 'simple\_1', 'spher1d\_1', 'spher2d\_1', \\'test\_scattering\_1']}\\
\item[3] Create a parameter file with the default values

{\tt >>> radmc3dPy.analyze.writeDefaultParfile('ppdisk')}\\


To change the parameters of the model the two most straightforward possibilities are the following:

a) Open the created 'problem\_params.inp' file with a text editor and change the parameters if needed. 

b) When in  Step\,4. the 'problemSetupDust()' method is called one can add keyword arguments with the parameter
names, e.g.:

{\tt>>>radmc3dPy.setup.problemSetupDust('ppdisk', mdisk='0.01*ms])}\\

The 'problemSetupDust()' method does the following in this case: Reads the problem\_params.inp file. Then 
overwrites the value of the mdisk parameter and uses that the new value afterwards. It also re-writes the problem\_params.inp
file with the new values. 

NOTE: If the value of the keyword argument is given as a string it will be written as a string unchanged to the 'problem\_params.inp' file
but will be interpreted and converted to double/float/int within the setup script. I.e. if mdisk='0.01*ms' is given as a keyword argument
in the call of problemSetupDust()  then in the problem\_params.inp file it will appear in the exact same way: mdisk='0.01*ms'. 
However, if the keyword argument is given as mdisk=0.01*ms the problem\_params.inp will contain mdisk = 1.9900000e+31. 


\item[4] Set up the model and create all necessary input files.


{\tt>>>radmc3dPy.setup.problemSetupDust('ppdisk')}\\

Then we need to copy the dust opacity file called 'dustkappa\_silicate.inp' from the python\_examples/datafiles directory
within the distribution root directory to the current model directory. 

\item[5] Then run RADMC-3D from the shell with the Monte-Carlo simulation to calculate the dust temperature.

{\tt \$>radmc3d mctherm}\\

Alternatively we can also make a system call from within Python, e.g.:

{\tt>>>import os}\\
{\tt>>>os.system('radmc3d mctherm')}
\item[6] After the thermal Monte-Carlo run has finished we can make an image from within pyton. 

{\tt \$>radmc3dPy.image.makeImage(npix=400, sizeau=200, wav=880., incl=45, posang=43.)}\\
\item[7] After RADMC-3D finished we can read the image and plot it. 

{\tt>>>imag=radmc3dPy.image.readImage()}\\
{\tt>>>radmc3dPy.image.plotImage(imag, arcsec=True, dpc=140., log=True, maxlog=5)}

Here 'arcsec=True' sets the image axes to arc second that also requires the knowledge of the distance, 
which is set in parsec by the 'dpc=140.' keyword. The 'log=True', sets logarithmic stretch of the image.
The 'maxlog=5' sets a clip of the displayed image by 10$^{-5}$ below its maximum value, i.e. the
displayed image values will be between max(image) and max(image)*10$^{-5}$.

\item[8] We can also convolve the image with an arbitrary elliptical gaussian Gaussian beam

{\tt>>>conv\_imag = imag.imConv(fwhm=[0.05, 0.1], pa=40., dpc=140.)}

The fwhm of the Gaussian beam should be in arcsec,  the positing angle of the major axis of the beam ellipse
should be in degrees, and the distance to the source in pc (dpc keyword) should be given. 

\item[9] We can also write the image into a fits file:

{\tt>>>imag.writeFits(fname='image.fits', dpc=140., coord='03h0m0s -29d0m0s')}



\end{itemize}


\newpage
\section*{Gas model setup} 

\begin{figure}
\begin{center}
\scalebox{0.8}{
\begin{tikzpicture}


% Input nodes
\node [input] (grid) {{\bf Spatial \& Frequency grid}\\amr\_grid.inp, \\wavelength\_micron.inp};
\node [input, below of=grid, yshift=-1.em] (radsource) {{\bf Radiation source(s)} \\ stars.inp};
\node [input, below of=radsource, yshift=-1.em] (dustopac) {{\bf Dust opacity} \\ dustkappa\_xxx.inp, dustopac.inp};
\node [input, below of=dustopac, yshift=-1.em] (dustdens) {{\bf Dust density} \\ dust\_density.inp};
%\node [input, below of=dustdens, yshift=-1.em] (dusttemp) {{\bf Dust temperature} \\ dust\_temperature.dat};
\node [input, below of=dustdens, yshift=-2.em] (codepar) {{\bf Code parameters} \\ radmc3d.inp};

\node [opinput, below of=codepar, yshift=-1.em] (gastemp) {{\bf Gas temperature} \\ gas\_temperature.dat};
\node [opinput, below of=gastemp, yshift=-1.em] (velocity) {{\bf Velocity} \\ gas\_velocity.inp};
\node [opinput, below of=velocity, yshift=-1.em] (gasdens) {{\bf Gas density} \\ numberdens\_xxx.inp};
\node [opinput, below of=gasdens, yshift=-1.em] (moldata) {{\bf Molecular data} \\ molecule\_xxx.inp};
\node [opinput, below of=moldata, yshift=-1.em] (linesinp) {{\bf Line RT setup} \\ lines.inp};



% MC calculation
\node [calc, right of=dustopac, xshift=13.em] (thermalmc) {{\bf Themal Monte-Carlo ($\rightarrow$ T$_{\rm dust}$)} \\ dust\_temperature.dat};
% Excitation calculation
\node [calc, right of=thermalmc, xshift=-2.4em, yshift=-28.em] (excitation) {{\bf Excitation \\ ($\rightarrow$ Level pop.)} \\ };

% Observables
\node [output, right of=thermalmc, xshift=13.em, yshift=5em] (contsed) {{\bf Raytracing \\ SED} \\ spectrum.out};
\node [output, right of=thermalmc, xshift=13.em, yshift=-5em] (contimag) {{\bf Raytracing \\ Image} \\ image.out};

\node [output, right of=excitation, xshift=13.em, yshift=5em] (spectrum) {{\bf Raytracing \\ Spectrum} \\ spectrum.out};
\node [output, right of=excitation, xshift=13.em, yshift=-5em] (cmap) {{\bf Raytracing \\ Channel map} \\ image.out};

% Lines/arrows
\path [line] (grid) -| node[xshift=3em, yshift=-10em] {} (thermalmc);
\path [line] (radsource) -| node[xshift=1em, yshift=-10em] {} (thermalmc);
\path [line] (dustopac) -- (thermalmc);
\path [line] (dustdens) -| node[xshift=3em, yshift=10em] {} (thermalmc);
\path [line] (codepar) -| node[xshift=1em, yshift=10em] {} (thermalmc);

\path [line] (thermalmc) -- (contsed);
\path [line] (thermalmc) -- (contimag);


%\path [line] (gastemp) -- (excitation);
\path [line] (gastemp) -| node[xshift=3em, yshift=-10em] {} (excitation);
\path [line] (velocity) -| node[xshift=3em, yshift=-10em] {} (excitation);
\path [line] (gasdens) -| node[xshift=3em, yshift=10em] {} (excitation);
\path [line] (moldata) -| node[xshift=3em, yshift=10em] {} (excitation);
\path [line] (linesinp) -| node[xshift=3em, yshift=10em] {} (excitation);
\path [line] (thermalmc) -- (excitation);


\path [line] (excitation) -- (spectrum);
\path [line] (excitation) -- (cmap);
\path [line] (thermalmc) -- (spectrum);
\path [line] (thermalmc) -- (cmap);


\end{tikzpicture}}
\end{center}
\caption{Structure of a dust + gas model. Dust inputs are marked with blue, gas inputs are marked with yellow, intermediate calculation, data products are
in red while green marks the output of the simulation.}
\end{figure}

\subsection*{radmc3dPy commands}
\begin{itemize}

\item[1] Follow the instructions for the dust models from Step 1. to 5. 
%\item[1] Import \pymod.
%
%{\tt >>> import radmc3dPy}\\
%\item[2] Check which models are available:
%
%{\tt >>> radmc3dPy.setup.get\_model\_names()}\\
%\indent {\tt ['ppdisk']}\\
%\item[3] Create a parameter file with the default values
%
%{\tt >>> radmc3dPy.analyze.write\_default\_parfile('ppdisk')}\\
%\item[4] Exit python and open the created 'problem\_params.inp' file with a text editor and change the parameters if needed. 
%Create all necessary imput files.
%
%{\tt>>>radmc3dPy.setup.problem\_setup\_gas('ppdisk')}\\
%\item[5] This time we can skip the thermal Monte-Carlo simulation and go directly to raytracing, calculating images
%and spectra.
\item[6] Create the necessary input files for the gas simulations:

{\tt>>>radmc3dPy.setup.problemSetupGas('ppdisk')}\\

\item[7] Calculate a channel map at a single frequency/wavelength

{\tt \$>radmc3d image npix 400 sizeau 200 incl 45. phi 0. posang 43. iline 3 vkms 1.0}\\
\item[6] This command calculates a single channel map at 

{\tt>>>imag=radmc3dPy.image.readImage()}\\
{\tt>>>radmc3dPy.image.plotImage()}

\end{itemize}









\end{document}